<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Array Iteration Method : 순환 구조에서 사용하는 메서드</h1>
    <ul>
        <li>array.reduce(callback function(total,value,index,self),[init value])
            누적값을 리턴 </li>
        <li>array.every(callback function(value,index,self));
            콜백 리턴 조건에 모든 배열의 값이 만족하면 true, false를 리턴 (&&) </li>
        <li>array.some(callback function(value,index,self));
            콜백 리턴 조건에 하나의 값이라도 만족하면 true/false를 리턴 (||) </li>
        <li>array.indexOf('str', [start index]);
            해당 문자열이 배열에 존재하면 index를 리턴 </li>
        <li>array.lastIndexOf('str', [start index]);
            뒤에서 부터 탐색 </li>
        <li>array.find(callback function(value,index,self));
            리턴 조건에 만족하는 첫 값을 리턴 </li>
        <li>array.findIndex(callback function(value,index,self));
            리턴 조건에 만족하는 첫 값의 index를 리턴 </li>
        <li>array.form('객체') : 순서가 있거나, 순환 구조를 갖고 있는 객체를 배열로 변환 </li>
        <li>array.keys() : 배열이 사용중인 key(index)를 검색하여 새로운 배열로 리턴 </li>
        <li>array.enterties() : index:value의 구조값을 만들어서 새로운 배열로 리턴</li>
        <li>array.includes("str") : 배열에 str 값이 있으면 true / false 리턴</li>
        <li></li>
    </ul>

    <script>
        const fruits = ['apple','banana','orange','apple','mango'];
        let f = fruits.entries();
        console.log(f); // Array Iterator라는 객체로 출력
        //f.forEach 안됨
        for(let a of f){
            console.log(a);
        }

        let find = fruits.indexOf('apple',1);
        console.log(find); // ('apple')에선 0 출력, ('apple',1)에선 3 출력  

        console.log(fruits.includes('apple')); // true
        console.log(fruits.includes('banana')); // true
        console.log(fruits.includes('kiwi')); // false

        const arr = [2,3,4,4,60,8,8,40,2,10];

        const sum = arr.reduce(function(total, v){
            return total+v;
        }, 1000) // [init value] 초기값 부여

        console.log(sum);

        let s = 0;
        arr.forEach(function(v){
            s += v;
        })
        console.log(s)
        // 50~52 reduce와 같은 기능

        let find1 = arr.find(function(v){
            return v >= 10;
        });

        console.log(find1);

        console.log(arr.findIndex((v)=>{
            return v >= 10;
        }));

        let even = arr.every((e)=>{
            return e % 2 == 0;
        })
        
        console.log(even); // false : 모두 짝수는 아니다.
        
        let even2 = arr.some( (e) => e%2==0 ); //줄여서 쓸 수 있음.   
        //콜백 함수의 내용이 return 하나밖에 없다면 return을 생략할 수 있다. **return을 생략할때 {}도 같이 생략해야함
        //let even2 = arr.every((e)=>{return e%2==0;}) 에서 return만 없앤 것

        console.log(even2);
        
        let even3 = arr.some( e => { return e%2==0 } );
        //파라미터의 ()도 하나만 사용한다면 생략가능
        console.log(even3);

        //filter를 활용한 배열의 중복 제거
        //현재 요소가 이전에 등장하지 않은 경우만 true
        console.log(arr);
        const onlyArr = arr.filter((v,i,s)=>{
            return s.indexOf(v) == i;
        });

        console.log(onlyArr);

    </script>
</body>
</html>